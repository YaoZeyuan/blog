---
title: 今日阅读-工作相关内容
date: 2022-06-25 13:00:00
tags: what-read-today
---

# 缘起

虽然看过很多好文章, 但一直没找到整理的地方, 后续再找时也不方便. 最近翻 github 时看到了陶文整理的[今日阅读](https://github.com/taowen/awesome-lowcode/blob/master/%E4%BB%8A%E6%97%A5%E9%98%85%E8%AF%BB.md)文件, 记录每天看到的优秀文章, 贴下链接, 附一两句简单的评论, 感觉是一个不错的方案

一方面, 阅读经历本身不涉及关键隐私, 分享好文可以创造信息. 另一方面, 也可以作为外人了解我们的途径. 没有明显坏处但成本低有收益的事, 是可以做一做的.

故有此页面

> 记录日常读到的和工作相关的文章/链接
> 长期更新

- 2022 年 7 月 9 日
  - [leetcode 分类总结](https://lefttree.gitbooks.io/leetcode-categories/content/index.html)
    - `刷题`
    - 按照解题思路对 leetcode 进行归类, 用于 hack 面试时的最后一道算法题
  - [谈谈工作中的犯错](https://catcoding.me/p/avoid-mistake/)
    - `业务`
    - 介绍业务中影响比较大的错误.
    - `信息泄漏`/`退款接口(重复调用)`/`并发问题`/`配置错误`/
    - `错误是个人和团队最好的学习、提高的机会，而且我们已经交了学费。`
    - 对于业务, 需要考虑`防御式编程`, 同时, 也要注意开发成本的控制
    - 经验总结
      - 安全是第一位的，我们在工作中对敏感信息、公司资产要有一定的安全意识。完全按照公司的安全准则来工作，否则提桶跑路可能是小事，被追究法律责任就麻烦了。
      - 任何线上操作都是危险的，如非必要不要进行手动的线上操作。操作的时候尽量慢，然后想清楚如果错了如何恢复。比如删东西尽量软删除，把要删的东西移动目录或者设置状态。
      - 如果一个动作是有危险的，应该思考如何把这动作自动化，如果是必须有人给输入，那需要一定的流程来进行 Review 和批准。
      - 微软还有个好实践就是所有的线上命令，如果是写入型的命令默认不能运行，需要手动地运行命令提升权限。
      - 运维方面，如果有条件和时间尽量往 Infrastructure as Code 方向上靠，减少人工进行操作。
- 2022 年 7 月 4 日
  - [编程语言：类型系统的本质](https://mp.weixin.qq.com/s/j7ljExrt_poSEuPYbr9AYQ)
    - `编程语言`
    - 通过类型系统, 实现编程正确性证明
    - 可以作为兴趣进行了解, 工作中用处不大, 但很有意思.
  - [web 前端面试 - 面试官系列](https://vue3js.cn/interview/)
    - `前端面试-题库`
    - 类似八股, 但好处是属于明牌, 用来对自己查缺补漏也可以
    - 当然更希望的是实际理解这些题目的含义, 而非简单背题.
- 2022 年 6 月 28 日
  - Taro3 跨端跨框架原理初探, https://mp.weixin.qq.com/s/CO92HJjhsP97cXwEBMPGUA
    - `小程序原理`
    - 对 react-reconciler 应用原理, web-component 组件库选择方案, 以及对 react 的适配
  - 书摘
    - `人工智能`
    - 只有在莱特兄弟停止模仿鸟并开始使用风洞且开始了解空气动力学后后，对『人工飞行』的追求才获得成功。航空工程的教材不会把其领域目标定义为制造『能完全像鸽子一样飞行的机器，以致他们可以骗过其他真鸽子』
    - `人工智能:一种现代的方法`解释为什么人工智能领域研究者全力研究智能的基本原理，而非致力于通过图灵测试
  - 面试
    - 前端早早聊, C8-9 额台-如何考察候选人的能力与潜力
    - 三面时会问:
      - 产品的业务模式是什么
      - 背后技术的整体架构是什么，你在这里边扮演了什么角色
      - 你的位置，你做了什么事情
      - 然后会结合他的回答，往里面挖
      - 你在 XX 这里遇到了什么问题，解决了什么问题，沉淀了什么东西
      - 如果碰到了候选人没考虑到的事，那么会问
      - 假设我给你提了这么一个要求，你会怎么考虑这个问题，怎么制定技术的解决方案
      - 借此观察候选人怎么思考这个问题，怎么分解，怎么找到问题中的关键点
      - 结合关键点怎么设计技术架构，怎么推动落地，在推动落地的过程中，考虑到质量，效率，团队协作这些问题
      - 三面面试官会仔细看前两面的面试记录，对于已问过的问题不再问，改为以候选人层级+1 的难度提问，以确认候选人的潜力，考察他思考未知问题的思维方式，来判断他未来往下一层级成长的潜力
      - 我在这个职位未来一年/三年的责任是什么
      - 你对我有什么期望
- 2022 年 6 月 26 日
  - https://www.zhihu.com/question/61131777/answer/2545197189, 为什么在中国只有一个时区，但是却有很多的时区代码？
    - `编程冷知识`
    - 在 java6 中, 对上海时区(Asia/Shanghai)而言, `1927-12-31 23:54:07` 和 `1927-12-31 23:54:08` 不是相差 1, 而是相差 353
      - 源代码
        ```java
        // via https://stackoverflow.com/questions/6841333/why-is-subtracting-these-two-times-in-1927-giving-a-strange-result
        public static void main(String[] args) throws ParseException {
            SimpleDateFormat sf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            String str3 = "1927-12-31 23:54:07";
            String str4 = "1927-12-31 23:54:08";
            Date sDt3 = sf.parse(str3);
            Date sDt4 = sf.parse(str4);
            long ld3 = sDt3.getTime() /1000;
            long ld4 = sDt4.getTime() /1000;
            // output => 353
            System.out.println(ld4-ld3);
         }
        ```
      - 原因是 1928 年民国对上海时区进行了调整, 上海时区往前调整了 5:52，所以时钟上相邻的 1 秒实际间隔 353 秒.
      - js 中该值正常, 估计是时区数据库没有那么详细.
        - 但仍然可以找到反直觉行为, 相关测试代码为
        ```js
        let time_1 = new Date("1986-05-04 02:00:00");
        let time_2 = new Date("1986-05-04 03:00:00");
        // output => 0
        console.log(time_1.valueOf() - time_2.valueOf());
        ```
        - 原因在这里
          - ![中共中央办公厅、国务院办公厅关于在全国范围内实行夏时制的通知-中办发〔1986〕12号-1986年4月12日](http://tva1.sinaimg.cn/large/007Yq4pTly1h3ld7is0dlj30kk0zjtph.jpg)
    - 解决方法是尽量选择正确的时区来处理时间数据, 剩下的交给专业时区数据库进行处理
      - 例如: 这个库 https://github.com/eggert/tz/blob/0e8f0b06ac2f65d0c54a91121da09c8662cd88e6/asia?utm_oi=26676952039424#L664
  - https://zhuanlan.zhihu.com/p/533850515 利用 shields.io 构造带数字的 Github 图片
    - `开发小工具`
    - 构造出的图片地址 https://img.shields.io/badge/dynamic/json?label=citationCount&query=citationCount&url=https%3A%2F%2Fapi.semanticscholar.org%2Fgraph%2Fv1%2Fpaper%2Fabd1c342495432171beb7ca8fd9551ef13cbd0ff%3Ffields%3DcitationCount
      - 实际请求内容 => label=citationCount&query=citationCount&url=https://api.semanticscholar.org/graph/v1/paper/abd1c342495432171beb7ca8fd9551ef13cbd0ff?fields=citationCount
    - 效果示例: ![效果](https://img.shields.io/badge/dynamic/json?label=citationCount&query=citationCount&url=https%3A%2F%2Fapi.semanticscholar.org%2Fgraph%2Fv1%2Fpaper%2Fabd1c342495432171beb7ca8fd9551ef13cbd0ff%3Ffields%3DcitationCount)
- 2022 年 6 月 24 日
  - https://www.zhihu.com/question/25539382/answer/539557939
    - `密码学`
    - 介绍了一些密码学可以实现的神奇效果以及对应的关键字:
      1. A 可以向 B 证明自己拥有一个密码，但是如果 B 是假冒的验证者，A 不会透露关于密码的任何信息给 B。——`零知识证明`
      2. A 可以和 B 比较自己持有的一个值的大小关系，而不泄露这个值给对方。——`百万富翁问题`
      3. A 可以给 B 发来的一段信息进行电子签名，而不知道信息的内容。——`盲签名`
      4. A 和 B 可以，在没有公正第三人的情况下，进行等概率胜负的博弈。——`电子博弈`(又称 `公平掷币协议` )
      5. 邮件服务，如果不考虑法律风险的话，是可以做到让服务器看不到你的邮件内容的。——PGP
      6. 不可能破解
         1. 破解 4096 位 RSA 是困难的。——即使用超算也如此。
         2. 破解 256 位 AES 是困难的。——即使用量子计算也如此。
         3. 破解 OTP 系统是困难（划掉）不可能的。——即使天顶星人来了也如此。
      7. 公开的安全算法才是可信的算法
         1. 一个好的加密算法真的应该是公开的——它可以接受更多人的检验。
         2. 一个好的密码系统不一定是公开的——但是它应该按照可以公开除了密码之外的一切而依旧安全来设计。
      8. 可以实现这样的算法，使得班干部中的任何一个均可以以班委会的名义下达通知，且其他人，除了班长之外，都不知道具体下达者。
         - 我理解可以这样设计
           1. 班委本身有对外的公钥私钥体系, 公钥公开, 因此所有人都可以验证消息来自班委
           2. 班委本身私钥不公开, 部署在服务器上, 只有班长可以登录
           3. 班委成员向班委服务器提交公钥, 服务器只允许认证过的班委成员调用私钥发送消息(期间私钥不对外展示)
           4. 对外表现为: 每一个班委成员都可以以班委的身份发送消息, 除了班长在中间可以看到该消息提供方的公钥签名外, 他人只能看到班委在发送消息, 而不知道具体的发送者
      9. 密码系统的安全性取决于最弱的一环……当年是谁说的`只用 https 保护登录界面就够了`的来着…你的 token 也会被盗
         1. 参考著名漫画: [绝对安全的加密方法……](https://mp.weixin.qq.com/s/ggxNrLQ0au-pK06dN2KUcA)
      10. 大多数密码系统都不是被正面攻破的…而是实现过程中出了差错…
      11. 以上内容，真的，真的，在大多数的密码学教材上都能找到——甚至还有用到的一些算法安全性的数学证明…
  - 在这个回答下的评论(来自@invalid s)
    - 提问: 请问前端如何实现两次发的密码 hash 值不同的？是要怎么加盐么？或者推荐个简明教材也好，多谢楼主
    - 作者回复:[w2014](https://www.zhihu.com/people/w2014-66)就是客户端向服务器申请登录时，服务器给客户端提供一个随机的 salt，而客户端把密码加 salt 做 hash 之后提交给服务器…因为不同次登录拿不到同样的 salt，所以 hash 结果就不一样了……
    - [invalid s](https://www.zhihu.com/people/s.invalid)回复
      - 简单说，这叫`挑战-应答`模式。
      - 服务器知道 MD5（用户密码+盐），它就可以向用户发出`挑战`——你说你是 alice，那么，你的密码、拼上我发过去的盐，算出 MD5 后，再拼上服务器的当前时间 xx 年 xx 月 xx 日 x 时 x 分 x 秒，然后再算一次 MD5：现在，告诉我这个 MD5！
      - 现在，随便谁，哪怕你全程监控着双方的通信，也不可能知道这个服务器和用户都知道的 MD5（用户密码+盐） 是多少。因为它从来就不曾在线路上出现过，只有真正的服务器和真正的用户才知道、才能计算出这个最终的 MD5、才能确认这个最终 MD5 是否正确。
      - 这就是所谓的挑战-应答模式。
      - 事实上，oauth2 认证、你登录网络游戏用的电子令牌，它们都是这个原理。
  - 作者推荐了 结城浩的[图解密码技术](https://book.douban.com/subject/26822106/)作为入门读物
